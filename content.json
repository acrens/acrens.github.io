{"meta":{"title":"acrens - F2E","subtitle":"acrens","description":"主要以记录技术分享为主，次要记录部分生活","author":"acrens","url":"https://acrens.github.io"},"pages":[{"title":"关于我","date":"2017-11-05T05:28:01.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"about/index.html","permalink":"https://acrens.github.io/about/index.html","excerpt":"","text":"姓名：程仁 出生年月：1992.9 家乡：江西上饶 现在所在公司：丁香园 邮箱 acrens@163com github (GitHub) 扫一扫，加好友"},{"title":"Categories","date":"2017-11-05T05:28:01.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"categories/index.html","permalink":"https://acrens.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-05T05:28:01.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"tags/index.html","permalink":"https://acrens.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack@1.x 基础配置","slug":"2017-11-05-webpack@1.x","date":"2017-11-05T22:30:00.000Z","updated":"2017-11-05T14:37:24.000Z","comments":true,"path":"2017/11/06/2017-11-05-webpack@1.x/","link":"","permalink":"https://acrens.github.io/2017/11/06/2017-11-05-webpack@1.x/","excerpt":"目前 webpack 已经更新到 3.x 版本，但是还有很多公司由于历史原因，不能够去升级 webpack 版本，猜测可能原因包括太多项目都使用 1.x 版本，同时构建端也统一都是 1.x 版本，如果需要升级更新就需要投入一定的人力资源去测试，最近刚好在整理 webpack 1.x 配置文件内容，借此记录下整理出来的版本内容。","text":"目前 webpack 已经更新到 3.x 版本，但是还有很多公司由于历史原因，不能够去升级 webpack 版本，猜测可能原因包括太多项目都使用 1.x 版本，同时构建端也统一都是 1.x 版本，如果需要升级更新就需要投入一定的人力资源去测试，最近刚好在整理 webpack 1.x 配置文件内容，借此记录下整理出来的版本内容。 webpack@1.x 基础配置写在前面有了这次 webpack@1.x 的整理经验，也让我更加深入的了解了各个配置项的实际作用及 webpack 的核心内容及工作方式，所以建议每个人还是亲手去每一项、每一项的去测试体验，这样才能更加深刻的理解每个配置项的作用，以便应用到实际工作中。以下整理出的内容会根据实际项目把变量提出去来当做常量控制，适应不同项目对插件应用的方式，因为会使用 babel，所以最好的使用方式就是通过配置 .babelrc 的方式，以下也会对此进行讲解。 webpack.config.js 文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const path = require('path');const webpack = require('webpack');const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); // 抽取 css 插件const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin'); // 压缩、优化 css 插件const autoprefixer = require('autoprefixer');const precss = require('precss');const IS_EXTRACT_CSS = true; // 是否开启抽取 css 文件，true 开启，false 不开启const env = process.env.NODE_ENV; // 开发环境为 developconst config = &#123; devtool: 'source-map', // 生成 SourceMap 文件 output: &#123; libraryTarget: 'var', // 暴露返回值给一个变量 library: '', // 不对外暴露任何名称 umdNamedDefine: false // 不定义 umd 名称 &#125;, module: &#123; // 在 loaders 之前对代码进行 eslint 检查 preLoaders: [ &#123; test: /\\.(js|jsx)$/, exclude: /node_modules/, loader: 'eslint-loader' &#125; ], loaders: [ &#123; test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/, query: &#123; cacheDirectory: path.join(process.cwd(), '.cache') &#125; &#125;, &#123; test: /\\.(png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/, loader: 'file-loader' &#125; ] &#125;, postcss: [ autoprefixer(&#123; browsers: ['last 3 versions', '&gt; 1%'] &#125;), // 样式添加前缀，兼容浏览器查看地址：http://browserl.ist/?q=%3E+1%25%2C+Last+3+versions precss ], resolve: &#123; extensions: ['', '.js', '.jsx', '.css', '.less'], // 解析组件的文件后缀白名单 // 配置路径别名，模块内可以直接使用别名 alias: &#123; 'common_path': path.join(__dirname, 'source/common'), 'modules_path': path.join(__dirname, 'source/modules'), 'pages_path': path.join(__dirname, 'source/pages') &#125; &#125;, // 排除以下内容打包到 bundle，减小文件大小 externals: &#123; 'react': 'window.React', 'react-dom': 'window.ReactDOM', './React': 'React', './ReactDOM': 'ReactDOM' &#125;, plugins: []&#125;;// 判断是否抽取 css 文件if (IS_EXTRACT_CSS) &#123; config.module.loaders.push( &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader?sourceMap!postcss-loader') &#125;, &#123; test: /\\.less$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader?sourceMap!postcss-loader!less-loader') &#125; ); config.plugins.push( new ExtractTextPlugin(\"[name].css\") // 提取组件 css 文件 );&#125; else &#123; config.module.loaders.push( &#123; test: /\\.css$/, loader: 'style-loader!css-loader?sourceMap!postcss-loader' &#125;, &#123; test: /\\.less$/, loader: 'style-loader!css-loader?sourceMap!postcss-loader!less-loader' &#125; );&#125;// 生产环境则压缩打包代码if (env !== 'develop') &#123; config.plugins.push( // 压缩 css new OptimizeCssAssetsPlugin(&#123; cssProcessor: require('cssnano'), // 加载 cssnano 优化 css cssProcessorOptions: &#123; discardComments: &#123; removeAll: true // 删除所有注释 &#125; &#125; &#125;), // 解析、压缩 js 代码 new webpack.optimize.UglifyJsPlugin(&#123; comments: false, // 去掉注释 compress: &#123; warnings: false // 忽略警告 &#125; &#125;), new webpack.optimize.OccurrenceOrderPlugin() // 模块最短 ids 长度 ); delete config.devtool; // 不生成 SourceMap 文件&#125;module.exports = config; .babelrc 配置文件1234567891011121314151617&#123; \"presets\": [ \"react\", \"stage-0\", [\"env\", &#123; \"targets\": &#123; \"browsers\": [\"last 3 versions\", \"&gt; 1%\"] &#125; &#125;] ], \"plugins\": [ \"jsx-control-statements\", \"transform-decorators-legacy\", \"transform-es3-member-expression-literals\", \"transform-es3-property-literals\" ]&#125; package.json 部分插件版本 如果插件版本和 webpack 版本未对上，也会导致变异错误而无法使用 webpack 编译，以下为部分使用插件版本，以下版本可以项目根据实际情况作出调整 123456789101112131415161718192021222324252627282930&#123; &quot;autoprefixer&quot;: &quot;^7.0.1&quot;, &quot;babel-core&quot;: &quot;^6.17.0&quot;, &quot;babel-eslint&quot;: &quot;^6.1.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-plugin-transform-class-properties&quot;: &quot;^6.9.1&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;, &quot;babel-plugin-transform-es3-member-expression-literals&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-es3-property-literals&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-object-assign&quot;: &quot;^6.22.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;, &quot;css-loader&quot;: &quot;^0.28.3&quot;, &quot;cssnano&quot;: &quot;^3.10.0&quot;, &quot;eslint&quot;: &quot;^3.19.0&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-react&quot;: &quot;^6.4.1&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^1.0.1&quot;, &quot;file-loader&quot;: &quot;^0.11.1&quot;, &quot;jsx-control-statements&quot;: &quot;^3.1.5&quot;, &quot;less&quot;: &quot;^2.7.1&quot;, &quot;less-loader&quot;: &quot;^3.0.0&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^1.3.1&quot;, &quot;postcss-loader&quot;: &quot;1.0.0&quot;, &quot;precss&quot;: &quot;^1.4.0&quot;, &quot;style-loader&quot;: &quot;^0.13.1&quot;, &quot;webpack&quot;: &quot;^1.13.1&quot;, &quot;webpack-livereload-plugin&quot;: &quot;^0.8.1&quot;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://acrens.github.io/tags/webpack/"}],"keywords":[]},{"title":"加入新公司的第 45 天","slug":"2017-11-04-mugu","date":"2017-11-05T13:30:00.000Z","updated":"2017-11-05T05:46:44.000Z","comments":true,"path":"2017/11/05/2017-11-04-mugu/","link":"","permalink":"https://acrens.github.io/2017/11/05/2017-11-04-mugu/","excerpt":"确切的说 2017-11-04 是我加入新公司的第 45 天，也就是试用期的刚刚好一半时间。我为什么要写这篇文章呢？这也跟我入职新公司的习惯有关系，在前四十天，我基本每十天会做一个大的总结，同时也算纪念。刚好现在试用期时间已过半，再次以文章的形势整体总结下这段时间的融入、认识、收获。以下都是自身的浅薄认识，望赐教。","text":"确切的说 2017-11-04 是我加入新公司的第 45 天，也就是试用期的刚刚好一半时间。我为什么要写这篇文章呢？这也跟我入职新公司的习惯有关系，在前四十天，我基本每十天会做一个大的总结，同时也算纪念。刚好现在试用期时间已过半，再次以文章的形势整体总结下这段时间的融入、认识、收获。以下都是自身的浅薄认识，望赐教。 加入新公司的第 45 天写在前面确切的说 2017-11-04 是我加入新公司的第 45 天，也就是试用期的刚刚好一半时间。我为什么要写这篇文章呢？这也跟我入职新公司的习惯有关系，在前四十天，我基本每十天会做一个大的总结，同时也算纪念。刚好现在试用期时间已过半，再次以文章的形势整体总结下这段时间的融入、认识、收获。以下都是自身的浅薄认识，望赐教。 融入写到这里我首先真诚的感谢公司对于入职第一天的安排，能够让我重新的认识公司的整体。我最最最感谢的还是学姐，记得第一天入职，快到午饭时间，我还在参加入职培训，当然这个时候其实是有点饿了，平时没有吃早饭的规律，刚好那天没吃。入职培训参加完毕，学姐亲自带我到工位，认识新的同事、新的工作环境、新的工作内容，这个时候学姐说午饭帮你点好了，当时顿时内心太温暖，学姐也很细心，这么好的团队成员，一下子让我对未来的工作更加的有些期许。有了这么好的一个开篇，那么接下来的一切自然而然也很顺利，再说我本身对于新环境的适应能力也是相对比较没问题，我甚至有时候喜欢这种挑战，这样才能够培养我适应新环境的能力。 对于新的工作内容，我花了一些时间去了解。当我接到工作内容时，我不是马上上手就开始写代码，因为这样会让你捉襟见肘，甚至无从下手。我先做了以下工作： 搭建项目本地运行环境（跑起来了才能开干）； 了解系统基础业务（分解需求思路更加清晰）； 协调相关开发人员（减少开发时外界的阻碍）； 学习系统技术体系（保持系统整体风格，减少后期维护成本）； 开始 coding（期间有任何疑问要第一时间咨询学姐）。 按照上面的流程依次进行，让我很轻松的融入到这个开发体系，为后期高质高量的完成需求打好了一个坚实的基础。 总之，对于新人而言，最头疼的事情无非就是如何快速、清晰的融入团队。把这件事情清晰的认识清楚，可以减少因为新环境带来的痛苦感。 收获当然，对于我们自身而言。最重要的还是收获，总结的目的就是提出问题、思考问题、解决问题。你甚至每天都要去思考，今天你接触了新的内容，你能够提出什么问题，提出问题后，你有没有好的解决方案。在公司这段时间，自身还是有很多收获的，比如：认识了新的同事，接触了新的工作环境，了解了新的系统、新的业务，学习了新的技术等等。 这里主要聊聊技术方面的收获，工程化是项目开发的一个难题，因为工程化做得好能够提升团队成员的开发效率，专心投入到编写业务代码中。这一方面公司整体做的还是不错，从项目初始化，到代码测试，再到代码发布。整个流程都有详细的节流控制，能够很好的把控代码规范、代码质量。主要问题可能还是在发布系统整体速度较慢，还不够灵活，希望这个能够后期有所提升。当下hexo generatehexo generate比较流行的组件化开发思想也能够得到很好的应用，封装好的组件库，我也阅读了组件库的源代码，基本思想和之前学习的基本一致，但是只有在实际工作中应用到了才能知道它的好。我希望在以后能够把该组件库能够推上一个层次，进行一些优化，这也是我比较感兴趣的事情。 希望能够在后续的时间里接触到更多的东西，学习到更多的内容。也希望自身能够主动的去发现一些问题，解决一些问题，给团队带来更多不一样的东西。 团队互联网公司基本都比较偏年轻化，更何况我们的口号是“让一般人类更美丽”，可见我们团队是更加的年轻化，更加的充满时尚感。来到这里确实会让你更加的有时尚感，如蘑菇街 app 的购衣搭配体验很 nice。在上面你不仅仅可以购衣，app 还能够帮你搭配衣服，让你有个更加合适的购衣体验。 我们团队每个人都有自己的特点，让我感触最大的就是，开开心心、轻轻松松的工作环境。这样说主要是团队成员总有那么几个能够营造轻松、开心氛围的伙伴。再说，笑容能够拉近人与人之间的具体，谁不愿意在这样的环境下工作呢。其实说到团队我是想以后单独来聊聊我们团队，更加细腻的去聊聊每个人的特点，团队的构成，团队的技术体系，团队的业务范畴等等跟团队密不可分的内容。 最后以上也是草草寥寥的写了那么多，都是根据自己的加入公司的实际体验的感悟。最终还是希望能够更加完美的融入这个团队，也希望能够在不久的将来给团队带来一些不一样的东西，给公司业务出一份绵薄之力。最后希望在接下来的 45 天里能够有更多的收获。","categories":[],"tags":[],"keywords":[]},{"title":"浏览器渲染那些事之 Reflow、Repaint","slug":"2017-03-22-reflow&repaint","date":"2017-03-22T22:09:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2017/03/23/2017-03-22-reflow&repaint/","link":"","permalink":"https://acrens.github.io/2017/03/23/2017-03-22-reflow&repaint/","excerpt":"在进行网页开发的时候，一般会忽略到页面渲染给浏览器带来的性能问题；在实际情况中，浏览器进行页面渲染会进行大量的计算，来确定每个可见元素在屏幕上的精确位置、大小，还需要将每个确定好的像素绘制到屏幕上，这些操作都需要消耗大量的资源；如果反复的进行这些操作，对用户设备性能损耗不容乐观，因此希望通过这篇文章加深大家对浏览器渲染过程的理解，并希望大家能够重视渲染过程带来的性能问题。","text":"在进行网页开发的时候，一般会忽略到页面渲染给浏览器带来的性能问题；在实际情况中，浏览器进行页面渲染会进行大量的计算，来确定每个可见元素在屏幕上的精确位置、大小，还需要将每个确定好的像素绘制到屏幕上，这些操作都需要消耗大量的资源；如果反复的进行这些操作，对用户设备性能损耗不容乐观，因此希望通过这篇文章加深大家对浏览器渲染过程的理解，并希望大家能够重视渲染过程带来的性能问题。 浏览器渲染那些事之 Reflow、Repaint浏览器内核（渲染引擎）在各个浏览器厂商你追我赶的形势下，截止今日，产生了很多不同的浏览器，各个浏览器本质大同小异，核心部分基本相似，由渲染引擎和 JS 引擎组成。当你在访问网站页面的时候，浏览器做了很多事情，从发送请求，到解析 HTML 源码，构建渲染树，最后将内容像素绘制到设备屏幕上，一步步完成用户最终需要的场景。然而，在浏览器完成整个渲染的过程中，最为核心的就是“渲染引擎”。以下分别列出一些主流浏览器的渲染引擎： chrome - webkit safari - webkit opera - webkit（早期是 presto） firefox - gecko ie - trident 渲染流程结合浏览器渲染原理，来剖析以下代码渲染构建过程： HTML 源码： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;title&gt;browser rendering&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=\"awesome-photo.jpg\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS 源码： 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 该图为以上源代码构建树： 浏览器渲染页面整个过程描述： 首先，解析 HTML Source，构建 DOM Tree； 同时，解析 CSS Style，构建 CSSOM Tree； 然后，组合 DOM Tree 与 CSSOM Tree，去除不可见元素，构建 Render Tree； 再执行 Reflow，根据 Render Tree 计算每个可见元素的布局（几何属性）； 最后，执行 Repaint，通过绘制流程，将每个像素渲染到屏幕上。 注意： Render Tree 只包含渲染网页所需要的节点； Reflow 过程是布局计算每个对象的精确位置和大小； Repaint 过程则是将 Render Tree 的每个像素渲染到屏幕上。 哪些阶段影响渲染效率我们都知道，网页是需要挂载在客户端的浏览器上运行，但是随着互联网的快速发展，为保证用户访问应用的流畅性，往往对客户端的设备配置要求较高。然而，对于用户的设备，我们是无法控制；因此，作为一名开发者，就需要找到除了用户设备配置之外导致访问不流畅的问题，下面就从渲染流程中找到影响性能的问题。 浏览器初始化渲染时会执行一次 Reflow 过程，这个过程主要是用来确定页面上每个元素在屏幕上的几何位置属性。但是，每执行一次 Reflow 会需要花费大量的时间，耗费大量的设备资源，所以尽量避免执行 Reflow 过程。同时，执行完 Reflow 都会伴随着一次 Repaint 过程，这个过程也会耗费大量的计算机资源，严重影响页面的渲染性能。所以，在浏览器渲染阶段，主要影响页面渲染的阶段是 Reflow 和 Repaint 过程，因此在编写代码时应该尽量避免 Reflow 和 Repaint 过程的执行，如：避免在 JS 代码里直接改变元素的几何属性。 reflow &amp; repaint 简介 reflow 在渲染过程中称为回流，发生在 Render Tree 阶段，它主要是用来确定每个元素在屏幕上的几何属性，需要大量计算每个元素的位置。在代码里每改变一个元素的几何属性，均会发生一次回流过程。 repaint 在渲染过程中称为重绘，发生在 reflow 过程之后，当元素的几何属性确定之后便要开始将元素绘制在屏幕上展示。repaint 执行过程就是将元素的颜色、背景等属性绘制出来。在代码里没改变一次元素的颜色等属性时均会对相关元素执行一次重绘。 如何触发 reflow 和 repaint 过程 改变元素 font-size： 1document.getElementsByTagName('body')[0].style.fontSize = '20px'; // reflow,repaint 改变元素盒模型margin、border、padding、width： 12345let styles = document.getElementsByTagName('body')[0].style;styles.margin = '40px'; // reflow,repaintstyles.border = '40px solid #f00'; // reflow,repaintstyles.padding = '40px'; // reflow,repaintstyles.width = '300px'; // reflow,repaint 改变元素颜色、背景色属性： 123let styles = document.getElementsByTagName('body')[0].style;styles.color = '#fff'; // repaintstyles.backgroundColor = '#f00'; // repaint 特殊：offset、scroll、client*、getComputedStyle、currentStyle： 由于浏览器在处理批量修改页面元素样式时，会将批量操作缓存起来，然后再做一次 reflow 过程（异步 reflow），避免每次操作都执行 reflow 消耗资源。但是如果在某个操作之后立马调用了以上执行属性，为了等够得到最新的样式，会检查缓存的操作，是否需要 reflow，这样就 flush 出最新的样式。 如何减少 reflow 和 repaint 过程 减少 JS 逐行修改元素样式： 12let body = document.getElementsByTagName('body')[0];body.className += ' class-name'; 离线处理 DOM 操作： 通过 documentFragment 集中处理临时操作； 克隆节点进行操作，然后进行原节点替换； 使用 display:none; 进行批量操作。 减少样式的重新计算，即减少 offset、scroll、client*、getComputedStyle、currentStyle 的使用，因为每次调用都会刷新操作缓冲区，执行 reflow &amp; repaint。 参考资料 渲染性能； Rendering: repaint, reflow/relayout, restyle - 译文； 浏览器的渲染原理简介； 分析运行时性能； 如何使用 Timeline 工具。","categories":[{"name":"浏览器渲染","slug":"浏览器渲染","permalink":"https://acrens.github.io/categories/浏览器渲染/"}],"tags":[{"name":"Reflow","slug":"Reflow","permalink":"https://acrens.github.io/tags/Reflow/"},{"name":"Repaint","slug":"Repaint","permalink":"https://acrens.github.io/tags/Repaint/"}],"keywords":[{"name":"浏览器渲染","slug":"浏览器渲染","permalink":"https://acrens.github.io/categories/浏览器渲染/"}]},{"title":"line-height 取值方式","slug":"2017-03-11-lihe-height","date":"2017-03-11T17:30:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2017/03/12/2017-03-11-lihe-height/","link":"","permalink":"https://acrens.github.io/2017/03/12/2017-03-11-lihe-height/","excerpt":"相信很多前端er都使用过 line-height 来设置行高布局。下面看看官方定义：On block level elements, the line-height property specifies the minimum height of line boxes within the element.On non-replaced inline elements, line-height specifies the height that is used to calculate line box height.","text":"相信很多前端er都使用过 line-height 来设置行高布局。下面看看官方定义：On block level elements, the line-height property specifies the minimum height of line boxes within the element.On non-replaced inline elements, line-height specifies the height that is used to calculate line box height. line-height 取值方式有时候我们在开发的时候并没有太深入的去了解一个属性，比如：line-height 的不同取值达到的效果并不同，下面依次看看常用的几种取值方式。 px 单位取值line-height: 26px 目的就是直接定义目标元素的行高为 26px 的高度。 % 百分比取值line-height: 150% 一般用该方式定义目标元素的行高会配合 font-size: 14px 属性使用，因为用百分比当前元素的行高为 1.5 * 14px = 21px。且如果其层叠子元素没有定义 line-height 属性，不管有没有定义 font-size 属性，其层叠子元素行高均为 21px（与自身的 font-size 没有任何关系）。 倍数取值line-height:1.5 用该方式一般也是配合 font:14px 属性使用，但是对层叠子元素的影响效果并不同，如果层叠子元素没有定义 line-height 属性，但是定义了 font-size 属性，那这些层叠子元素的行高为继承过来的 line-height 倍数值乘以自身的 font-size 属性。 总结一般情况下，为了更加方便及清晰的使用 line-height，使用倍数取值是最佳的设置方式，如：body {font: 12px/1.5 tahoma,arial,”\\5b8b\\4f53”}。","categories":[{"name":"line-height","slug":"line-height","permalink":"https://acrens.github.io/categories/line-height/"}],"tags":[{"name":"css","slug":"css","permalink":"https://acrens.github.io/tags/css/"},{"name":"line-height","slug":"line-height","permalink":"https://acrens.github.io/tags/line-height/"}],"keywords":[{"name":"line-height","slug":"line-height","permalink":"https://acrens.github.io/categories/line-height/"}]},{"title":"javascript 中 TDZ 的理解","slug":"2017-01-22-TDZ","date":"2017-01-22T14:15:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2017/01/22/2017-01-22-TDZ/","link":"","permalink":"https://acrens.github.io/2017/01/22/2017-01-22-TDZ/","excerpt":"春节快到了，假期也快到了，空闲之余刷个微博，看见 @ruanyf 提出了一个问题与 TDZ 有关，但是貌似阮大当时还没有意识到这个问题，多亏一些其他业内同仁提出了与 TDZ 相关；当然，以阮大的能力这都不是事。由于当时我本身也还不知道 TDZ 这一回事没有看懂，所以就花了一些时间去搞清楚什么是 TDZ 及TDZ会带来一些什么问题，本文主要是用于介绍我对 TDZ 的一些理解，如有问题，多谢指出。","text":"春节快到了，假期也快到了，空闲之余刷个微博，看见 @ruanyf 提出了一个问题与 TDZ 有关，但是貌似阮大当时还没有意识到这个问题，多亏一些其他业内同仁提出了与 TDZ 相关；当然，以阮大的能力这都不是事。由于当时我本身也还不知道 TDZ 这一回事没有看懂，所以就花了一些时间去搞清楚什么是 TDZ 及TDZ会带来一些什么问题，本文主要是用于介绍我对 TDZ 的一些理解，如有问题，多谢指出。 示例 案例一 代码 12345let y = 1;function foo(x = y, y) &#123; console.log(x);&#125;foo(); // ReferenceError: y is not defined 解读 当函数存在默认参数时，且调用方法不传任何参数，会存在三个作用域环境； 全局作用域、参数作用域、函数体作用域； 当执行 foo 函数时，参数作用域在 x = y 之后才定义 let y，注意：let 定义，所以根据 let 定义变量的作用知道 x = y 肯定会报错； 代码翻译：将以上代码翻译之后可以按下面代码片段阅读更易于理解123456789101112function analysis() &#123; \"use strict\"; let y = 1; function foo() &#123; let x = arguments[0] !== (void 0) ? arguments[0] : y; // y not defined let y = arguments[1]; &#125; foo(); return &#123;&#125;;&#125; 案例二 代码 12345678let y = 1;function foo(x = function()&#123;console.log(y)&#125;, y = 2) &#123; x(); // 2 y = 3; x(); // 3&#125;foo();console.log(y); //1 解读 当函数存在默认参数时，且调用方法不传任何参数，会存在三个作用域环境； 全局作用域、参数作用域、函数体作用域； 当执行 foo 函数时，x 被申明为匿名函数变量，此时函数并未被执行，所以正常；之后定义 y 值为 2，此时调用 x() 输出的当然是变量 y 的值，之后继续修改 y 的值，再继续调用 x()，输出 y 最新值 3；当执行外部 console.log(y) 时并不能访问内部函数变量，访问的变量是当前域下的 y = 1 的值 1，所以输出 1； 代码翻译：将以上代码翻译之后可以按下面代码片段阅读更易于理解123456789101112131415161718function analysis() &#123; \"use strict\"; let y = 1; function foo() &#123; let x = arguments[0] !== (void 0) ? arguments[0] : function() &#123; console.log(y); &#125;; let y = arguments[1] !== (void 0) ? arguments[1] : 2; x(); // 2 y = 3; x(); // 3 &#125; foo(); console.log(y); // 1 return &#123;&#125;;&#125; 案例三 代码 123456let y = 1;function foo(x = function()&#123;console.log(y)&#125;) &#123; let y = 3; x(); // 1&#125;foo(); 解读 当函数存在默认参数时，且调用方法不传任何参数，会存在三个作用域环境； 全局作用域、参数作用域、函数体作用域； 当执行 foo 函数时，x 被赋值为一个匿名函数的变量，且存在与参数作用域内，let y = 3 会被定义到函数体作用域内，属于参数作用域的内部函数；当 x() 执行时是在函数体作用域定被调用，但是其定义是在参数作用域，所以执行环境是在参数作用域内，此时在参数作用域没有定义 y 变量，也不能访问内部函数 funBody 内部定义的变量 y，此时往上级函数查找是否存在 y 被定义，如果被定义则输出其值，所以输出最外层变量 y 的值 1； 代码翻译：将以上代码翻译之后可以按下面代码片段阅读更易于理解12345678910111213141516171819function analysis() &#123; \"use strict\"; let y = 1; function foo() &#123; let x = arguments[0] !== (void 0) ? arguments[0] : function() &#123; console.log(y); &#125;; function funBody() &#123; let y = 3; x(); &#125; funBody(); &#125; foo(); return &#123;&#125;;&#125; 案例四 代码 12345function foo(x = function()&#123;console.log(y)&#125;) &#123; let y = 3; x(); // // ReferenceError: y is not defined&#125;foo(); 解读 当函数存在默认参数时，且调用方法不传任何参数，会存在三个作用域环境； 全局作用域、参数作用域、函数体作用域； 当执行 foo 函数时，x 被赋值为一个匿名函数的变量，且存在与参数作用域内，let y = 3 会被定义到函数体作用域内，属于参数作用域的内部函数；当 x() 执行时是在函数体作用域定被调用，但是其定义是在参数作用域，所以执行环境是在参数作用域内，此时在参数作用域没有定义 y 变量，也不能访问内部函数 funBody 内部定义的变量 y，此时往上级函数查找是否存在 y 被定义，如果被定义则输出其值，否则报 y 没有被定义错误，此案例只是案例三的一种测试； 代码翻译：将以上代码翻译之后可以按下面代码片段阅读更易于理解1234567891011121314151617function analysis() &#123; \"use strict\"; function foo() &#123; let x = arguments[0] !== (void 0) ? arguments[0] : function() &#123; console.log(y); &#125;; function funBody() &#123; let y = 3; x(); &#125; funBody(); &#125; foo(); return &#123;&#125;;&#125; 参考以上核心部分在代码翻译部分，通过配合一下资料及个人的理解，翻译出通俗易懂的代码： https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters https://github.com/google/traceur-compiler/issues/1604","categories":[{"name":"TDZ（Temporal Dead Zone）","slug":"TDZ（Temporal-Dead-Zone）","permalink":"https://acrens.github.io/categories/TDZ（Temporal-Dead-Zone）/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://acrens.github.io/tags/javascript/"},{"name":"TDZ","slug":"TDZ","permalink":"https://acrens.github.io/tags/TDZ/"},{"name":"Temporal Dead Zone","slug":"Temporal-Dead-Zone","permalink":"https://acrens.github.io/tags/Temporal-Dead-Zone/"}],"keywords":[{"name":"TDZ（Temporal Dead Zone）","slug":"TDZ（Temporal-Dead-Zone）","permalink":"https://acrens.github.io/categories/TDZ（Temporal-Dead-Zone）/"}]},{"title":"关于组建一支精良团队的构想","slug":"2016-11-29-fe_team","date":"2016-11-29T21:38:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2016/11/30/2016-11-29-fe_team/","link":"","permalink":"https://acrens.github.io/2016/11/30/2016-11-29-fe_team/","excerpt":"今年双十一也过去一段时间，在双十一的大潮中，产生了很多匪夷所思的大数据。天猫的 1207 亿元成交额。在这些大数据的背后，有多少团队在为之付出，又有多少人为之倾尽全力。双十一过后的几周，我不断在订阅号里看见双十一带来的连锁反应，各种技术文章，看了让人心动。但是我又因此思考，如何在这场战争后继续保持一个团队的稳定及继续勇往向前冲的态度。那就是”打造一支精良的团队”。","text":"今年双十一也过去一段时间，在双十一的大潮中，产生了很多匪夷所思的大数据。天猫的 1207 亿元成交额。在这些大数据的背后，有多少团队在为之付出，又有多少人为之倾尽全力。双十一过后的几周，我不断在订阅号里看见双十一带来的连锁反应，各种技术文章，看了让人心动。但是我又因此思考，如何在这场战争后继续保持一个团队的稳定及继续勇往向前冲的态度。那就是”打造一支精良的团队”。 认识一致我们可以从技术角度去要求每位团队成员必须达到指定的一个技术体系，也就是解决现已有产品需求的最基本，也是最完善的能力。这样可以节约团队资源，无缝隙的快速接入一个产品。 既然聊到了”技术体系”这个词，下面聊聊他的作用及范围，由于本人是从事前端开发工作，可能更了解前端体系，这里就根据我浅陋的了解说说我对”技术体系”的想法。 我很认同的一句话：技术体系归根结底是要围绕业务发展、团队规模和团队特点量身打造的，主要目的是为了提升团队整体的研发效率，确保线上的质量和稳定性。 开发团队的任务就是完成产品业务，而在完成业务的同时要考虑的东西包括：资源、投入、质量、稳定等等。那前端团队如何通过自身特点去解决这些问题？ 流程规范 代码规范，如遵循 airbnb javascript 规范； git 版本管理，如遵循 gitflow 分支规范； 部署规范，分开发、试用、正式三个环境，多机备份，等等。 技术工具栈 技术栈说到底应该是没有限制的，因为这需要根据开发工程师及项目实际业务需求做出最合适的技术选型。但是至少得学会一种最近流行的框架，有备无患，这也是作为一个前端开发者的必备素养。但不管怎么样，你至少会 vue 全家桶、react 全家桶、angular 中的一种吧？如果您是一个移动端爱好的前端开发者，你或许还可以学习 Weex（Vue Native）者 React Native，站在前端开发的角度开发多端兼容的 App。write less do more。 构建工具栈 构建工具如同技术工具栈，但相比又更加主观，开发者可以根据自行需求选用合适的构建工具，不管是选择 yeoman、gulp、webpack、grunt、sass、less、babel、npm、yarn 里面的一个或者多种的组合，最主要的还是要切合团队配合及实际项目需要。 测试工具栈 测试工具可以选用比较常用的 Mocha、Chai、Karma、intern、jasmine ，对于前端代码而言，进行前端代码自动化测试是保证代码的质量和健壮性的一项可行方案。 部署流程及部署平台 部署流程是控制上线资源前的最后一道规范限制，部署也需要运维及 DB 严格把控（当然这里可能是指严格把控后端操作数据库）。 部署平台是发布资源的最后一道工序，可能按钮一点，新资源就全部一键发布上线。但是为了提高前端团队发布效率，将发布系统与 git、svn 等版本控制系统结合起来构建一个发布资源平台，这样可以对发布资源做很多事情，多成员各自发布各自的互不影响，唯有管理员可以一键发布所有相关人员修改的代码，这样把发布代码不一致性降至最低。 监控体系 监控系统也是我最近很感兴趣的一件事情，淘宝的 JSTracker、腾讯的 badjs-report 都给了我很好的参考。而监控体系不仅仅局限于此，监控体系本身可以包含：日志上报、性能监控及错误监控等。这样能够第一时间让相关人员知道系统本身存在的问题并第一时间通知开发者，且第一时间修复减少因为此问题带来的损失。 想法各异在远古，摩擦升温是起火的一种方式。我希望我的团队每个人想法各异，并且勇于提出供大家讨论。这样的摩擦不至于不会摩擦升温提升大家的热情。","categories":[{"name":"FE team","slug":"FE-team","permalink":"https://acrens.github.io/categories/FE-team/"}],"tags":[{"name":"前端团队","slug":"前端团队","permalink":"https://acrens.github.io/tags/前端团队/"},{"name":"构想","slug":"构想","permalink":"https://acrens.github.io/tags/构想/"},{"name":"精良","slug":"精良","permalink":"https://acrens.github.io/tags/精良/"}],"keywords":[{"name":"FE team","slug":"FE-team","permalink":"https://acrens.github.io/categories/FE-team/"}]},{"title":"来，加入前端自动化单元测试","slug":"2016-09-20-fe_unit_test","date":"2016-09-20T23:30:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2016/09/21/2016-09-20-fe_unit_test/","link":"","permalink":"https://acrens.github.io/2016/09/21/2016-09-20-fe_unit_test/","excerpt":"最近闲来无事，开始摸索前端单元测试。一是不备之需，二是确实在实际项目中能够用到单元测试。这样可以提高开发效率，提升代码质量，完全可以单独对 JS 进行测试，无需页面，不依赖其他第三方。","text":"最近闲来无事，开始摸索前端单元测试。一是不备之需，二是确实在实际项目中能够用到单元测试。这样可以提高开发效率，提升代码质量，完全可以单独对 JS 进行测试，无需页面，不依赖其他第三方。 为什么需要单元测试在这里首先需要知道单元测试的目的及结果： 使代码健壮，质量高，兼容各种临界点； 减少 QA 测试报告的反馈，提高自我影响力； 保证代码的整洁清晰。 如果需要刨根问底追究为什么需要进行单元测试，那我们可以开始讲讲实际项目开发中遇到的一些问题： QA 不断反馈代码有 BUG （此时你正在投入的开发，然后被打扰…）； 代码出现 BUG，叠加代码修复 BUG（代码越来越难维护…）; 已经开发完成一个模块，但是没有页面提供调试测试； 你开发完成的功能，每次都有许多细小的 BUG（个人影响力下降…）。 好了，列举了这么多原因，相信你也开始心虚了，回去继续搬砖检查检查代码有没有问题，如果你面色从容，大神，请手下我的膝盖。 总结：单元测试的目的只有一个，用来确定是否适合使用 如何进行单元测试如果明白了为什么要进行单元测试，相信你已经可以开始着手为自己的代码写一些单元测试代码。测试从字面理解就是检验，看对象是否达标，达标就是 pass，不达标就是 fail。产品有这样一个需求，如果结果是 3 达到目标且返回的为有效的数字类型才可以进行比较，下面看个栗子：1234567891011121314151617181920/** * 获取 a 除以 b 的结果 * @param &#123;[Number]&#125; a [数字] * @param &#123;[Number]&#125; b [数字] * @return &#123;[Number]&#125; [结果数字] */function division(a, b) &#123; return a / b;&#125;// 测试代码function test() &#123; var result = division(6, 2); if (result === 3) &#123; console.log('pass'); &#125; else &#123; console.log('fail'); &#125;&#125; 咋一看上面的代码没什么问题，可以满足产品的需求，但是问题来了，如果 b 为 0，这个模块就出现了 BUG，同时如果下次需要达到其他的值就算通过，那就得去修改测试代码，这样的测试代码本身也太不健全。于是乎有了下面的方式：12345678910111213141516171819202122232425/** * 获取 a 除以 b 的结果 * @param &#123;[Number]&#125; a [数字] * @param &#123;[Number]&#125; b [数字] * @return &#123;[Number]&#125; [结果数字] */function division(a, b) &#123; if (b === 0) &#123; return 0; &#125; else &#123; return a / b; &#125;&#125;function test(name, result, expect) &#123; if (result === expect) &#123; console.log(name + '-&gt; pass'); &#125; else &#123; console.log(name + '-&gt; fail'); &#125;&#125;test('normal number', division(6, 2), 3);test('zero', division(6, 0), 0); 如果需要期望值为 10 就通过，那可以这样：1test('normal number is 10', division(20, 2), 10); 单元测试环境搭建及代码示例但是随着前端迅速的发展，也出现了很多测试框架，下面我演示我在实际项目中使用的测试框架环境配置 karma + jasmine，对于 karma、jasmine 我就不介绍，网上一搜一大把介绍： 安装 node 环境依赖于 node 作为基础环境，安装完成在控制台运行下面命令查看是否安装成功。 1node -v 新建目录并通过以下命令初始化项目配置 package.json 1npm init 在 package.json scripts: {} 添加以下内容： 1\"test\": \"karma start karma.conf.js\" 依次安装测试框架 12345npm install karma -gnpm install jasmine --save-devnpm install karma-jasmine --save-devnpm install karma-chrome-launcher --save-devnpm install jasmine-core --save-dev 或者一次性安装 12npm install karma -gnpm install jasmine karma-jasmine karma-chrome-launcher jasmine-core --save-dev 运行以下命令新建 karma.conf.js（根目录下不是必须） 1karma init 文件内容及说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * karma 自动化测试参数配置 */module.exports = function(config) &#123; config.set(&#123; // 基础路径，用在files，exclude属性上 basePath: '', // 可用的测试框架: https://npmjs.org/browse/keyword/karma-adapter frameworks: ['jasmine'], // 需要加载到浏览器的文件列表 files: [ './src/**/*.js', './test/unit/specs/*.spec.js' ], // 排除的文件列表 exclude: [ 'karma.conf.js' ], // 在浏览器使用之前处理匹配的文件 // 可用的预处理: https://npmjs.org/browse/keyword/karma-preprocessor preprocessors: &#123;&#125;, // 使用测试结果报告者 // 可能的值: \"dots\", \"progress\" // 可用的报告者: https://npmjs.org/browse/keyword/karma-reporter reporters: ['progress'], // web server port port: 9876, // 启用或禁用输出报告或者日志中的颜色 colors: true, /** * 日志等级 * 可能的值： * config.LOG_DISABLE //不输出信息 * config.LOG_ERROR //只输出错误信息 * config.LOG_WARN //只输出警告信息 * config.LOG_INFO //输出全部信息 * config.LOG_DEBUG //输出调试信息 */ // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // 启用或禁用自动检测文件变化进行测试 autoWatch: true, // 测试启动的浏览器 // 可用的浏览器: https://npmjs.org/browse/keyword/karma-launcher browsers: ['Chrome'], // 开启或禁用持续集成模式 // 设置为true, Karma将打开浏览器，执行测试并最后退出 singleRun: false, // 并发级别（启动的浏览器数） concurrency: Infinity, // 依赖插件 plugins: [ 'karma-chrome-launcher', 'karma-jasmine' ] &#125;)&#125; 新建源代码及测试代码目录，目录结构如下： 123456789101112project - node_modules - *(node 模块) - src - FQA - index.js - test - unit - specs - *.spec.js - karma.conf.js - package.json 测试代码 index.js 源码 1234567891011121314151617181920212223242526272829303132/** - test map method callback and parseInt param use - @return &#123;[Array]&#125; [Array] */ function checkMap() &#123; var nums = ['1', '2', '3']; return nums.map(parseInt); &#125; /** - test null is Object，and common object is same - @return &#123;[Array]&#125; [Array] */ function typeofAndInstanceOf() &#123; var result = []; result.push(typeof null); result.push(null instanceof Object); return result; &#125; /** - 检测操作符优先级 - @return &#123;[string]&#125; [返回字符串] */ function checkOperators() &#123; var result = 'autoTest'; result = 'Value is ' + (result === 'autoTest') ? 'Something' : 'Nothing'; return result; &#125; fqa.spec.js 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** - test index.js checkMap method - detail: - parseInt(val, base), base is 2 ~ 36, otherwise value equal NaN. */describe('test map and callback parseInt', function() &#123; it('a array call map', function() &#123; var nums = checkMap(); console.log(nums); expect([1, NaN, NaN]).toEqual(nums); &#125;);&#125;);/** - test index.js typeofAndInstanceOf method - detail: - typeof null qeual 'object', but null instanceof Object equal false, because null Constructor not Object. */describe('test null is object', function() &#123; it('null object', function() &#123; var result = typeofAndInstanceOf(); console.log(result); expect(['object', false]).toEqual(result); &#125;);&#125;);/** - test index.js checkOperators method - detail: - compare operator precedence, + gt ?. */describe('test null is object', function() &#123; it('test operator preceence', function() &#123; var result = checkOperators(); console.log(result); expect('Something').toEqual(result); &#125;);&#125;); 运行 sudo npm run test 执行测试代码 123\"scripts\": &#123; \"test\": \"karma start karma.conf.js\"&#125; 结果： 解答 npm run test 运行的实际上是 package.json 中配置的命令： 1\"test\": \"karma start karma.conf.js\" describe 定义测试模块，it 测试一个单元，describe 内部可以同时定义多个 it，因此可以做一系列的单元测试，测试方法详见官方文档。 karma.conf.js 配置 files 设置测试时需要被加载的文件1234files: [ './src/**/*.js', './test/unit/specs/*.spec.js'] 总结希望看完这篇文章，你也能够动起手来，开始编写一些单元测试代码，提高代码的质量，提升自己的周围影响力。本篇文章内容表述了实际项目开发中会遇到的问题，我们可以通过单元测试来减少这类问题的发生，以提高代码的安全性，代码的质量，从而保证产品的稳定性。","categories":[{"name":"自动化单元测试","slug":"自动化单元测试","permalink":"https://acrens.github.io/categories/自动化单元测试/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"https://acrens.github.io/tags/单元测试/"},{"name":"auto-unit-test","slug":"auto-unit-test","permalink":"https://acrens.github.io/tags/auto-unit-test/"}],"keywords":[{"name":"自动化单元测试","slug":"自动化单元测试","permalink":"https://acrens.github.io/categories/自动化单元测试/"}]},{"title":"XSS 防御之战","slug":"xss-1","date":"2016-09-11T22:34:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2016/09/12/xss-1/","link":"","permalink":"https://acrens.github.io/2016/09/12/xss-1/","excerpt":"写这篇文章主要是为了记录下最近项目开发中遇到的一个问题及解决过程；XSS 相信大家都知道，其相关知识就不在这里多讲；本篇文章主要侧重前端在获得后端给予的数据时是如何防御 XSS。 看到这里应该有人会说，后端都已经给你进行了 XSS 过滤，前端还需要做这些干什么，我的答案是：永远不要相信别人给你的东西是和你想要的 100% 一致。","text":"写这篇文章主要是为了记录下最近项目开发中遇到的一个问题及解决过程；XSS 相信大家都知道，其相关知识就不在这里多讲；本篇文章主要侧重前端在获得后端给予的数据时是如何防御 XSS。 看到这里应该有人会说，后端都已经给你进行了 XSS 过滤，前端还需要做这些干什么，我的答案是：永远不要相信别人给你的东西是和你想要的 100% 一致。 防御 XSS 攻击项目场景 前端基于 RESTful 风格 API 异步获取后端数据； 数据渲染都是通过 underscore template 渲染页面。 解决方案封装一个过滤特殊字符【如：&lt;、&gt;、%、@等】全局方法，供渲染数据之前调用。 但是发现项目是通过 underscore template 渲染页面的，想想可以在这里做点手脚；经过一番调研，果真如此，template 提供两种变量获取数据的方式，分别为：&lt;%= variable %&gt;、&lt;%- variable %&gt;。 &lt;%= variable %&gt; 不对数据做任何处理； &lt;%- variable %&gt; 对数据进行 HTML 转义（即特殊字符转义）。 经过多次尝试，现在有四种选择方案： &lt;%= variable %&gt; &amp; html(str)存在问题：如果后台未进行 XSS 防御，前台过滤无效： 1$('.J-content').html(_.template('&lt;%=content%&gt;', &#123;content: '&lt;script&gt;alert(1);&lt;/script&gt;'&#125;)); &lt;%= variable %&gt; &amp; text( str)存在问题：如果后台进行了 XSS 防御，前台展示数据未还原： 1$('.J-content').text(_.template('&lt;%=content%&gt;', &#123;content: '&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&#125;)); &lt;%- variable %&gt; &amp; html(str)存在问题：如果后台进行了 XSS 防御，前台展示数据未还原： 1$('.J-content').html(_.template('&lt;%-content%&gt;', &#123;content: '&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&#125;)); &lt;%- variable %&gt; &amp; text(str)存在问题：不管后台进行还是没进行 XSS 防御，前台展示数据均未还原： 123$('.J-content').text(_.template('&lt;%-content%&gt;', &#123;content: '&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&#125;));$('.J-content').text(_.template('&lt;%-content%&gt;', &#123;content: '&lt;script&gt;alert(1);&lt;/script&gt;'&#125;)); 灵机一动的我细心一想上述四种方法不可能不行，后台找到了原因所在，是因为 html 和 text 方法的区别，html 方法渲染页面会讲转义字符转换为 HTML 代码，text 方法渲染页面只是纯粹的内容替换，但是 html 方法只能将 &amp;amp 渲染成单独的 &amp;，所以通过 &lt;%- variable %&gt; 转义 &amp;lt 成 &amp;amp\\;lt 之后再由 html 方法渲染在页面显示为 &amp;lt，所以通过 replace 方法替换所有 &amp;amp，如下代码：1$('.J-content').html(_.template('&lt;%-content%&gt;', &#123;content: '&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&#125;).replace(/&amp;amp;/g, '&amp;'));","categories":[{"name":"XSS","slug":"XSS","permalink":"https://acrens.github.io/categories/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://acrens.github.io/tags/XSS/"}],"keywords":[{"name":"XSS","slug":"XSS","permalink":"https://acrens.github.io/categories/XSS/"}]},{"title":"浅谈网站性能之前端性能优化","slug":"2016-07-03-performance","date":"2016-07-03T13:49:00.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2016/07/03/2016-07-03-performance/","link":"","permalink":"https://acrens.github.io/2016/07/03/2016-07-03-performance/","excerpt":"最近项目慢慢走上正轨，需求趋于平稳，这才想起需要对整站进行性能优化。经过一段时间的学习，结合现在项目的实际性能情况，发现确实有许多地方可以进行优化。于是就开始了我的前端性能优化之旅。以下内容仅为个人理解，如果本内容大家觉得哪里写的不对，望大家指出，供一起讨论。","text":"最近项目慢慢走上正轨，需求趋于平稳，这才想起需要对整站进行性能优化。经过一段时间的学习，结合现在项目的实际性能情况，发现确实有许多地方可以进行优化。于是就开始了我的前端性能优化之旅。以下内容仅为个人理解，如果本内容大家觉得哪里写的不对，望大家指出，供一起讨论。 浅谈网站性能之前端性能优化性能优化的目的无非是减少用户流量消耗，提升用户首屏体验，提升用户访问速度，让用户专注内容本身。 前端性能优化 减少 HTTP 请求数量 基本原理：在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。 CSS Sprites：国内俗称 CSS 精灵，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数，节省命名词汇量（由命名多张图片文件变成一张，哈哈哈）。 合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。 采用 lazyLoad：俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。 控制资源文件加载优先级 基本原理：说到这里就需要知道浏览器加载 HTML 内容的原理，浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。 遵循原则：主要文件放在 head 内部，次要文件放在 body 底部。一般情况下都是 CSS 在头部，JS 在底部。 利用浏览器缓存 基本原理：浏览器缓存分强缓存和协商缓存，他们是将网络资源存储在本地，等待下次请求该资源时，如果命中就不需要到服务器重新请求该资源，直接在本地读取该资源。 强缓存：在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header。 协商缓存：通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 分别管理。 使用 CDN 基本原理：CDN的全称是Content Delivery Network，即内容分发网络。 减少重排（Reflow） 基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。 减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。 减少 DOM 操作 图标使用 IconFont 替换 花絮在开始提笔写这篇博客前就遇到了一个很棘手的问题，这篇博客标题叫什么，思考了一会，我心里冒出了三个答案： 浅谈网站性能优化 第一个标题网站性能优化，一看标题可以理解为是讲网站性能，而且是对网站进行优化，描述的是一种解决方案，然而网站性能包括的太多了，超出了我的知识范畴，所以放弃。 浅谈网站性能之前端性能优化 第二个标题正适我怀，答题概括了我本期博客内容，既有性能介绍，又有前端性能优化解决方案。 浅谈前端性能优化 第三个标题前端性能优化，心想这不就是我要写的内容嘛，等我写完内容发现，不对，我写的内容不仅仅是解决方案，好包括的其他内容，所以放弃。 以上内容仅为个人理解，如果本内容大家觉得哪里写的不对，望大家指出，供一起讨论。","categories":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://acrens.github.io/categories/前端性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://acrens.github.io/tags/性能优化/"}],"keywords":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://acrens.github.io/categories/前端性能优化/"}]},{"title":"Promise 讲解","slug":"2016-06-29-promise","date":"2016-06-29T09:21:14.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2016/06/29/2016-06-29-promise/","link":"","permalink":"https://acrens.github.io/2016/06/29/2016-06-29-promise/","excerpt":"曾经有伟人说过，对于一件新鲜事物，如果需要搞明白他，就会有以下三个步骤：What、How、Why（学习、思维三部曲 或 叫做学习黄金圈）；而对于很多人，在学习一门技术时，都停留在 What 阶段，到使用时就不知道如何使用，就算使用了也不知道为什么要用。","text":"曾经有伟人说过，对于一件新鲜事物，如果需要搞明白他，就会有以下三个步骤：What、How、Why（学习、思维三部曲 或 叫做学习黄金圈）；而对于很多人，在学习一门技术时，都停留在 What 阶段，到使用时就不知道如何使用，就算使用了也不知道为什么要用。 What（Promise 是什么）描述Promise 是抽象异步处理对象以及对其进行各种操作的组件，而且 Promise 并不是从 JavaScript 中发祥的概念。 状态Promise 具有三种状态，分别为 pending（执行中）、resolved（被接受）、rejected（被拒绝）。 方法实例化： var promise = new Promise(function(resolve, reject) {}); Promise.resolve() 等方法均可以直接返回一个新创建的 Promise 对象。 静态方法：Promise.all、Promise.race、Promise.resolve、Promise.reject： Promise.all() Promise.all 方法为 Promise 组件的静态方法，无需创建 Promise 对象就可以直接使用此方法来并行执行多个 Promise 对象，且在 Promise.all([“Promise1”，”Promise2”， “Promise2”])，如果在 all 方法参数的数组中有一个 Promise 对象执行失败即停止执行，返回结果需要等到数组对象执行完成才返回最后结果，结果为多个 Promise 对象返回值组成的数组。代码：123456var p1 = Promise.resolve(1)；var p2 = Promise.resolve(2)；var p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function(results) &#123; console.log(results); // [1, 2, 3]&#125;); Promise.race() Promise.race 方法性质同 Promise.all 方法，使用方式也一样，但是有一点不同是在 Promise.race([“Promise1”，”Promise2”，”Promise3”]) 等到数组参数里面第一个 Promise 对象执行完成就返回执行结果（这里说的第一个不是第一个参数，也可能是第二个，是指第一个执行完成的 Promise 对象）。代码：1Promise.race([new Promise(), new Promise(), new Promise()])； Promise.resolve() 这是一种直接到达 Promise resolved 状态的快捷方式，并且创建返回一个 Promise 对象。代码：123Promise.resolve(\"acrens\").then(function(name) &#123; console.log(name); // acrens&#125;); Promise.reject() 同理，这是达到 Promise rejected 状态的快捷方式，并且创建返回一个进行 reject 的新 Promise 对象。如果传入的参数为一个 Promise 对象，则返回的是一个新的 Promise 对象（和 resolve 不同）。代码：1Promise.reject(new Error(\"error\"))； 对象方法：new Promise().then、new Promise().catch： then() 用于注册 Promise 分别达到 resolved、rejected 状态时的回调函数，如：then(resolve, reject)，当达到 resolved 状态时，执行 resolve 方法，否则，执行 reject 方法；reject 函数可以不在此注册，可以使用 catch 注册（这也是注册 reject 方式的语法糖，更方便 Promise 链方法）；如果不需要注册 resolved 状态时的回调函数，then 方法第一个参数不可以省略，但是可以 then(undefined, reject) 这样书写。代码：123456789var promise = new Promise(function(resolve, reject) &#123; resolve(2);&#125;);promise.then(function(value) &#123; console.info('Task --------- ' + value); // Task --------- 2&#125;).catch(function onRejected(error) &#123; console.error(error);&#125;); catch() catch 方法在此就不多赘述，其只是注册 rejected 状态回调函数的语法糖。代码：（参照上面 then 方法代码示例）。 How（Promise 如何运行）Promise 从实例化到执行完成可以参照下图并结合上述代码理解（只有认真地去理解这个流程图，才可以看到 Promise 的精髓，坏笑…）：注意：fulfill 就相当 resolved 状态。 Why（Promise 为什么会产生）Promise 需要解决的问题也就是其产生的原因（废话）： 异步问题 用异步的方式来表达异步的代码是艰难的，甚至很难用我们的大脑来理解。（事件轮询、并发模式） 回调地狱 并不是简单地理解为代码嵌套，编辑器代码缩进空格；还包括代码的控制转移（如在回调之前进行的第三方调用，控制权转交给第三方）。 总结在项目开发中，时常会使用到异步处理及代码多层嵌套，这对于后期理解和维护代码是一个“坑”，因此可以尝试使用 Promise 方式去解决代码给后期带来的负担。 https://www.web-tinker.com/search/Promise%20%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/1.html http://liubin.org/promises-book/#introduction http://www.zhangxinxu.com/wordpress/2014/02/es6-javascript-promise-%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5/ http://www.sitepoint.com/overview-javascript-promises/ http://blog.getify.com/promises-part-1/ （译文：https://segmentfault.com/a/1190000000586666） https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","categories":[{"name":"Promise","slug":"Promise","permalink":"https://acrens.github.io/categories/Promise/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://acrens.github.io/tags/Promise/"}],"keywords":[{"name":"Promise","slug":"Promise","permalink":"https://acrens.github.io/categories/Promise/"}]},{"title":"JFinal学习笔记-Demo 部署-lesson02","slug":"2014-07-29-jfinal-lesson02","date":"2014-07-29T22:18:24.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2014/07/30/2014-07-29-jfinal-lesson02/","link":"","permalink":"https://acrens.github.io/2014/07/30/2014-07-29-jfinal-lesson02/","excerpt":"延续 JFinal lesson01，开始搭建一个 JFinal 案例","text":"延续 JFinal lesson01，开始搭建一个 JFinal 案例 JFinal 是 JAVA 极速 WEB 开发的开源框架一、环境：MyEclipse9+Tomcat6+MySql;二、准备 jar 包，如下图：三、开始在MyEclipse9+Tomcat6+MySql部署一个学生信息管理小Demo： 创建Web Project工程； 在WEB-INFO文件目录下新建lib文件夹并放入四个jar包，然后build path； 创建jfinalstudy01数据库并创建两张表student+classes，如下： 1234567891011121314create table classes( classesid int(4) not null, classesname varchar(40), classesaddress varchar(60));create table student( studentid int(4) not null, studentname varchar(10), studentage int(4), studentsex varchar(4), classesid int(4)); 添加以下配置至web.xml（同时新建JFinalAllConfig类）: 123456789101112131415161718192021222324252627282930313233343536373839public class JFinalAllConfig extends JFinalConfig &#123; @Override public void configConstant(Constants me) &#123; me.setDevMode(true); &#125; @Override public void configRoute(Routes me) &#123; me.add(\"/\", StudentController.class); me.add(\"/student\", StudentController.class); &#125; @Override public void configPlugin(Plugins me) &#123; C3p0Plugin cp = new C3p0Plugin( \"jdbc:mysql://localhost:3306/JFinalStudy01\", \"root\", \"\"); me.add(cp); ActiveRecordPlugin arp = new ActiveRecordPlugin(cp); me.add(arp); // 三个参数依次为表名、主键、model arp.addMapping(\"student\", \"studentid\", Student.class); arp.addMapping(\"classes\", \"classesid\", Classes.class); &#125; @Override public void configInterceptor(Interceptors me) &#123; // TODO Auto-generated method stub &#125; @Override public void configHandler(Handlers me) &#123; // TODO Auto-generated method stub &#125; &#125; 新建Student、Classes的model： Student： 1234567891011121314package com.phy.jfinal.model;import com.jfinal.plugin.activerecord.Model;public class Student extends Model &#123; private static final long serialVersionUID = 1L; public static final Student dao = new Student(); public Classes getClasses() &#123; return Classes.dao.findById(get(\"classesid\")); &#125;&#125; Classes： 12345678910package com.phy.jfinal.model;import com.jfinal.plugin.activerecord.Model;public class Classes extends Model &#123; private static final long serialVersionUID = 1L; public static final Classes dao = new Classes();&#125; 新建StudentController（接收HTTP请求处理的控制器）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.phy.jfinal.controller;import java.util.List;import com.jfinal.aop.Before;import com.jfinal.core.Controller;import com.phy.jfinal.interceptor.StudentInterceptor;import com.phy.jfinal.model.Student;import com.phy.jfinal.validator.StudentValidator;public class StudentController extends Controller &#123; private static int num = 0; // 进行获取学生信息列表前的拦截操作 @Before(StudentInterceptor.class) public void index() &#123; List list = Student.dao.find(\"select * from student\"); setAttr(\"studentList\", list); render(\"/index.html\"); &#125; public void add() &#123; render(\"/add.html\"); &#125; public void delete() &#123; // 获取url请求中第一个值 Student.dao.deleteById(getParaToInt()); forwardAction(\"/student\"); &#125; public void update() &#123; Student student = getModel(Student.class); student.update(); forwardAction(\"/student\"); &#125; public void get() &#123; Student student = Student.dao.findById(getParaToInt()); setAttr(\"student\", student); render(\"/index2.html\"); &#125; //StudentValidator是对进行保存操作时的变量的验证 @Before(StudentValidator.class) public void save() &#123; Student student = getModel(Student.class); student.set(\"studentid\", num++).save(); forwardAction(\"/student\"); &#125; &#125; 拦截器及验证器： 拦截器 1234567891011121314package com.phy.jfinal.interceptor;import com.jfinal.aop.Interceptor;import com.jfinal.core.ActionInvocation;public class StudentInterceptor implements Interceptor &#123; @Override public void intercept(ActionInvocation ai) &#123; System.out.println(\"action注入之前\"); ai.invoke(); System.out.println(\"action注入之后\"); &#125;&#125; 验证器 123456789101112131415161718192021package com.phy.jfinal.validator;import com.jfinal.core.Controller;import com.jfinal.validate.Validator;public class StudentValidator extends Validator &#123; //在校验失败时才会调用 @Override protected void handleError(Controller controller) &#123; controller.keepPara(\"student.studentname\");//将提交的值再传回页面以便保持原先输入的值 controller.render(\"/add.html\"); &#125; @Override protected void validate(Controller controller) &#123; //验证表单域name，返回信息key,返回信息value validateRequiredString(\"student.studentname\", \"studentnameMsg\", \"请输入学生名称!\"); &#125;&#125; 前台实现（通过freemarker读取数据），在WebRoot目录下新建index.html，add.html，change.html(分别为学生信息列表获取、学生信息添加、学生信息修改，下面依次列出实现代码)： index.html add.html change.html 三个CSS文件（添加在WebRoot目录下的css文件夹下： common.css add.css index.css 以下分别为整体项目目录结构及相关截图：","categories":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/categories/JFinal/"}],"tags":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/tags/JFinal/"}],"keywords":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/categories/JFinal/"}]},{"title":"JFinal学习笔记-知识介绍-lesson01","slug":"2014-07-28-jfinal-lesson01","date":"2014-07-28T22:21:24.000Z","updated":"2017-11-05T05:28:01.000Z","comments":true,"path":"2014/07/29/2014-07-28-jfinal-lesson01/","link":"","permalink":"https://acrens.github.io/2014/07/29/2014-07-28-jfinal-lesson01/","excerpt":"JFinal 相关文章是个人刚毕业不久使用过的一个 Java 后台框架，感觉上手容易，搭建迅速，易于构建小型 Web 项目，以此对 JFinal 做个记录。","text":"JFinal 相关文章是个人刚毕业不久使用过的一个 Java 后台框架，感觉上手容易，搭建迅速，易于构建小型 Web 项目，以此对 JFinal 做个记录。 JFinal 是 Java 极速 Web 开发的开源框架一、优点：入手快、学习花费少、开发迅速、代码量很少、易扩展、RESTful风格（扩展性好）。二、缺点：比较适合于小型WEB应用开发。三、特点： MVC 架构、设计精巧; 遵循 COC 原则、零配置、无附带xml文件; 独创Db + Record模式、灵活便利; ActiveRecord 支持，使数据库开发极致快速; 自动加载修改后的 java 文件，开发过程中无需重启 web server(如：tomcat); AOP 支持，拦截器配置灵活，功能强大; Plugin体系结构，扩展性强; 多视图支持，支持 FreeMarker、JSP、Velocity; 强大的 Validator 后端校验功能; 功能齐全，拥有 struts2 绝大部分核心功能; 体积小仅 218K，且无第三方依赖。 四、体系架构","categories":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/categories/JFinal/"}],"tags":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/tags/JFinal/"}],"keywords":[{"name":"JFinal","slug":"JFinal","permalink":"https://acrens.github.io/categories/JFinal/"}]}]}